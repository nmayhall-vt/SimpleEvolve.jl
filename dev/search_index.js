var documenterSearchIndex = {"docs":
[{"location":"#SimpleEvolve","page":"Home","title":"SimpleEvolve","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SimpleEvolve.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#SimpleEvolve.MultiChannelSignal","page":"Home","title":"SimpleEvolve.MultiChannelSignal","text":"MultiChannelSignal \nA struct to represent a multi-channel signal with multiple digitized signals.\n\n\n\n\n\n","category":"type"},{"location":"#SimpleEvolve.SignalSUM","page":"Home","title":"SimpleEvolve.SignalSUM","text":"SignalSum{T<:AbstractFloat}\n\nAlgebraic sum of multiple signal components.\n\n\n\n\n\n","category":"type"},{"location":"#SimpleEvolve.TanhEnvelope","page":"Home","title":"SimpleEvolve.TanhEnvelope","text":"TanhEnvelope{T<:AbstractFloat}\n\nSignal with hyperbolic tangent envelope for smooth transitions.\n\nFields\n\namplitude::T: Peak amplitude\nsigma::T: Rise/fall time constant\ncenter::T: Central time position\n\n\n\n\n\n","category":"type"},{"location":"#SimpleEvolve._step","page":"Home","title":"SimpleEvolve._step","text":"Auxiliary function to evolve a single step in time. \n\n\n\n\n\n","category":"function"},{"location":"#SimpleEvolve.amplitude_ti-Tuple{DigitizedSignal, Any}","page":"Home","title":"SimpleEvolve.amplitude_ti","text":"amplitude_ti(signal::DigitizedSignal, t)     Calculate the amplitude of a signal at time t using trigonometric interpolation     Args:         signal: Input digitized signal         t: Time at which to evaluate the signal     Returns:         Amplitude of the signal at time t\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.amplitude_ws-Tuple{DigitizedSignal, Any}","page":"Home","title":"SimpleEvolve.amplitude_ws","text":"amplitudews(signal::DigitizedSignal, t; windowradius=8)     Calculate the amplitude of a signal at time t using Whittaker-Shannon interpolation     from the signal samples of reduced size     Args:         signal: Input digitized signal         t: Time at which to evaluate the signal         window_radius: Number of samples on each side of the center sample (default is 8)     Returns:         Amplitude of the signal at time t\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.costfunction_direct_exponentiation-Tuple{Vector{ComplexF64}, Vector{Float64}, Matrix{ComplexF64}, Any, Int64, Any, Any, Float64}","page":"Home","title":"SimpleEvolve.costfunction_direct_exponentiation","text":"costfunctiondirectexponentiation(ψ0,                                     eigvals,                                    signal,                                     nsites,                                     drives,                                     T,                                      ntrottersteps,                                     Costham)\n\ncost_function for the system using direct exponentiation\nargs:\n    ψ0     : Initial state\n    eigvals: Eigenvalues of the Hamiltonian\n    signal : Signal to be evolved\n    n_sites: Number of sites in the system\n    drives : External drives applied to the system # annhilation operators in case of qubits\n    T      : Total time for evolution\n    n_trotter_steps: Number of Trotter steps for exponentiation\n    Cost_ham: Hamiltonian used for cost function calculation\nreturns:\n    cost   : Cost function value\n    ψ_direct: Evolved state\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.costfunction_ode_ssvqe-Tuple{Matrix{ComplexF64}, Vector{Float64}, Any, Int64, Any, Matrix{ComplexF64}, Float64, Any}","page":"Home","title":"SimpleEvolve.costfunction_ode_ssvqe","text":"costfunctionodeexcitedstates(ψ0, eigvals, signal, nsites, drives, eigvectors, T, Costham; basis=\"eigenbasis\", tolode=1e-8)\n\ncost_function for the system using ODE solver for excited states\nargs:\n    ψ0     : Initial state\n    eigvals: Eigenvalues of the Hamiltonian\n    signal : Signal to be evolved\n    n_sites: Number of sites in the system\n    drives : External drives applied to the system # annhilation operators in case of qubits\n    eigvectors: Eigenvectors of the Hamiltonian\n    T      : Total time for evolution\n    Cost_ham: Hamiltonian used for cost function calculation\n    basis  : Basis in which the evolution is performed (default is \"eigenbasis\")\n    tol_ode: Tolerance for ODE solver (default is 1e-8)\nreturns:\n    cost   : Cost function value\n    ψ_ode  : Evolved state\n\ncostfunction=sumi real(ψi' * Costham * ψ_i)\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.evolve_ODE_multiple_states-Tuple{Matrix{ComplexF64}, Float64, Any, Int64, Any, Any, Matrix{ComplexF64}}","page":"Home","title":"SimpleEvolve.evolve_ODE_multiple_states","text":"function to evolve multiple states using ODE solver simultaneously\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.infidelity-Tuple{Any, Any}","page":"Home","title":"SimpleEvolve.infidelity","text":"infidelity(ψ, φ)     Function to compute the infidelity between two state vectors     args:         ψ : First state vector         φ : Second state vector     returns:         infidelity value\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.penalty_gradient-Tuple{Any, Float64}","page":"Home","title":"SimpleEvolve.penalty_gradient","text":"penalty_gradient(Ω::Vector{ComplexF64}, Ω₀::Float64)     Computes the gradient of the penalty term for the control amplitudes Ω.         df(x)/dx = sign(x) * h * (1 + 1 / y^2) / Ω₀ for y > 0, y= abs(x) - 1         where h = exp(y - 1 / y)\n\nArgs:\n    Ω   : Control amplitudes\n    Ω₀  : Reference amplitude\nReturns:\n    grad : Computed gradient of the penalty term\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.projector-Tuple{Integer, Integer, Integer}","page":"Home","title":"SimpleEvolve.projector","text":"projector(n_sites::Integer, n_levels::Integer, n_levels0::Integer)\n\nProject a Hilbert space of n_sites n_levels0-level qubits onto that of n_sites n_levels-level qubits\n\nReturns an (n_sites^n_levels, n_sites^n_levels) shaped matrix Π. To perform the projection on a vector, use ψ ← Πψ. To perform the projection on a matrix, use A ← ΠAΠ'.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.reconstruct-Tuple{DigitizedSignal, Int64, Symbol}","page":"Home","title":"SimpleEvolve.reconstruct","text":"reconstruct(signal::DigitizedSignal,             outputsamples::Int,             method::Symbol;             secondarymethod=:polynomial,             weight=0.5,             polyorder=4,             windowradius=8,             filtercutoffratio=0.8)     Reconstruct a signal using specified interpolation methods.     Args:         signal: Input digitized signal         output_samples: Desired output length         method: Interpolation method to use     Returns:         Reconstructed signal with anti-aliasing\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.reconstruct_gradient_ti-Tuple{DigitizedSignal, Any}","page":"Home","title":"SimpleEvolve.reconstruct_gradient_ti","text":"reconstructgradientti(signal::DigitizedSignal, output_samples::Int)\n\nReconstruct a signal using trigonometric interpolation.\nArgs:\n    signal: Input digitized signal\n    output_samples: Desired output length\nReturns:\n    Reconstructed signal with anti-aliasing\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.single_step","page":"Home","title":"SimpleEvolve.single_step","text":"Auxiliary function to evolve a single step in time. \n\n\n\n\n\n","category":"function"}]
}
