var documenterSearchIndex = {"docs":
[{"location":"#SimpleEvolve","page":"Home","title":"SimpleEvolve","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SimpleEvolve.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#SimpleEvolve.MultiChannelSignal","page":"Home","title":"SimpleEvolve.MultiChannelSignal","text":"MultiChannelSignal \nA struct to represent a multi-channel signal with multiple digitized signals.\n\n\n\n\n\n","category":"type"},{"location":"#SimpleEvolve.QubitCoupling","page":"Home","title":"SimpleEvolve.QubitCoupling","text":"QubitCoupling(q1::Int, q2::Int)\n\nA struct of a pairwise coupling between two qubits.\n\nArguments\n\nq1::Int: Index of the first qubit.\nq2::Int: Index of the second qubit.\n\nReturns\n\nA QubitCoupling instance with the qubit indices ordered such that qubit_1 ≤ qubit_2.\n\n\n\n\n\n","category":"type"},{"location":"#SimpleEvolve.SignalSUM","page":"Home","title":"SimpleEvolve.SignalSUM","text":"SignalSum{T<:AbstractFloat}\n\nAlgebraic sum of multiple signal components.\n\n\n\n\n\n","category":"type"},{"location":"#SimpleEvolve.TanhEnvelope","page":"Home","title":"SimpleEvolve.TanhEnvelope","text":"TanhEnvelope{T<:AbstractFloat}\n\nSignal with hyperbolic tangent envelope for smooth transitions.\n\nFields\n\namplitude::T: Peak amplitude\nsigma::T: Rise/fall time constant\ncenter::T: Central time position\n\n\n\n\n\n","category":"type"},{"location":"#SimpleEvolve._step","page":"Home","title":"SimpleEvolve._step","text":"Auxiliary function to evolve a single step in time. \n\n\n\n\n\n","category":"function"},{"location":"#SimpleEvolve.amplitude_ti-Tuple{DigitizedSignal, Any}","page":"Home","title":"SimpleEvolve.amplitude_ti","text":"amplitude_ti(signal::DigitizedSignal, t)     Calculate the amplitude of a signal at time t using trigonometric interpolation     Args:         signal: Input digitized signal         t: Time at which to evaluate the signal     Returns:         Amplitude of the signal at time t\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.amplitude_ws-Tuple{DigitizedSignal, Any}","page":"Home","title":"SimpleEvolve.amplitude_ws","text":"amplitudews(signal::DigitizedSignal, t; windowradius=8)     Calculate the amplitude of a signal at time t using Whittaker-Shannon interpolation     from the signal samples of reduced size     Args:         signal: Input digitized signal         t: Time at which to evaluate the signal         window_radius: Number of samples on each side of the center sample (default is 8)     Returns:         Amplitude of the signal at time t\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.bandwidth_penalty-Tuple{AbstractVector{<:Real}}","page":"Home","title":"SimpleEvolve.bandwidth_penalty","text":"bandwidth_penalty(Ω::Vector{Float64}, ν::Float64; cutoff::Float64=0.2)\n\nComputes a smooth bandwidth penalty by suppressing high-frequency components in the Fourier domain using a smooth low-pass filter based on the error function.\n\nArguments\n\nΩ::Vector{Float64}: The input signal.\nν::Float64: Sharpness of the low-pass filter transition (higher ν = sharper).\ncutoff::Float64: Normalized frequency cutoff ∈ (0, 0.5). Frequencies above this are penalized.\n\nReturns\n\npenalty::Float64: Sum of squared differences between the original and filtered signal.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.costfunction_direct_exponentiation-Tuple{Vector{ComplexF64}, Vector{Float64}, Matrix{ComplexF64}, Any, Int64, Any, Any, Float64}","page":"Home","title":"SimpleEvolve.costfunction_direct_exponentiation","text":"costfunctiondirectexponentiation(ψ0,                                     eigvals,                                    signal,                                     nsites,                                     drives,                                     T,                                      ntrottersteps,                                     Costham)\n\ncost_function for the system using direct exponentiation\nargs:\n    ψ0     : Initial state\n    eigvals: Eigenvalues of the Hamiltonian\n    signal : Signal to be evolved\n    n_sites: Number of sites in the system\n    drives : External drives applied to the system # annhilation operators in case of qubits\n    T      : Total time for evolution\n    n_trotter_steps: Number of Trotter steps for exponentiation\n    Cost_ham: Hamiltonian used for cost function calculation\nreturns:\n    cost   : Cost function value\n    ψ_direct: Evolved state\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.costfunction_ode_ssvqe-Tuple{Matrix{ComplexF64}, Vector{Float64}, Any, Int64, Any, Matrix{ComplexF64}, Float64, Any}","page":"Home","title":"SimpleEvolve.costfunction_ode_ssvqe","text":"costfunctionodeexcitedstates(ψ0, eigvals, signal, nsites, drives, eigvectors, T, Costham; basis=\"eigenbasis\", tolode=1e-8)\n\ncost_function for the system using ODE solver for excited states\nargs:\n    ψ0     : Initial state\n    eigvals: Eigenvalues of the Hamiltonian\n    signal : Signal to be evolved\n    n_sites: Number of sites in the system\n    drives : External drives applied to the system # annhilation operators in case of qubits\n    eigvectors: Eigenvectors of the Hamiltonian\n    T      : Total time for evolution\n    Cost_ham: Hamiltonian used for cost function calculation\n    basis  : Basis in which the evolution is performed (default is \"eigenbasis\")\n    tol_ode: Tolerance for ODE solver (default is 1e-8)\nreturns:\n    cost   : Cost function value\n    ψ_ode  : Evolved state\n\ncostfunction=sumi real(ψi' * Costham * ψ_i)\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.costfunction_ssvqe_with_penalty_real-Tuple{Matrix{ComplexF64}, Vector{Float64}, Any, Int64, Any, Matrix{ComplexF64}, Float64, Any}","page":"Home","title":"SimpleEvolve.costfunction_ssvqe_with_penalty_real","text":"cost function that adds penalty terms for only real amplitudes Subspace search algorithm for excited states\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.evolve_ODE_multiple_states-Tuple{Matrix{ComplexF64}, Float64, Any, Int64, Any, Any, Matrix{ComplexF64}}","page":"Home","title":"SimpleEvolve.evolve_ODE_multiple_states","text":"function to evolve multiple states using ODE solver simultaneously\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.gradientsignal_ODE_multiple_states","page":"Home","title":"SimpleEvolve.gradientsignal_ODE_multiple_states","text":"This function computes gradient at each time step for complex pulse in cartesian representation\n\n\n\n\n\n","category":"function"},{"location":"#SimpleEvolve.infidelity-Tuple{Any, Any}","page":"Home","title":"SimpleEvolve.infidelity","text":"infidelity(ψ, φ)     Function to compute the infidelity between two state vectors     args:         ψ : First state vector         φ : Second state vector     returns:         infidelity value\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.kron_concat-Union{Tuple{T}, Tuple{AbstractArray{Matrix{T}, 1}, AbstractArray{Matrix{T}, 1}}} where T<:Number","page":"Home","title":"SimpleEvolve.kron_concat","text":"kron_concat(ops::AbstractVector{Matrix{T}}, O_::AbstractVector{Matrix{T}}) where T <: Number -> Matrix{T}\n\nComputes the sequential Kronecker product of a list of matrices and stores intermediate results in-place.\n\nArguments\n\nops::AbstractVector{Matrix{T}}: A vector of matrices (e.g., quantum operators on individual subsystems) to be Kronecker-tensored together.\nO_::AbstractVector{Matrix{T}}: Preallocated output buffer to store intermediate Kronecker products. Must have same length as ops.\n\nReturns\n\nO_[end]::Matrix{T}: The final matrix resulting from ops[1] ⊗ ops[2] ⊗ ... ⊗ ops[end].\n\nDescription\n\nThis function computes chained Kronecker products efficiently with in-place memory reuse using kron!.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.penalty_gradient-Tuple{Any, Float64}","page":"Home","title":"SimpleEvolve.penalty_gradient","text":"penalty_gradient(Ω::Vector{ComplexF64}, Ω₀::Float64)     Computes the gradient of the penalty term for the control amplitudes Ω.         df(x)/dx = sign(x) * h * (1 + 1 / y^2) / Ω₀ for y > 0, y= abs(x) - 1         where h = exp(y - 1 / y)\n\nArgs:\n    Ω   : Control amplitudes\n    Ω₀  : Reference amplitude\nReturns:\n    grad : Computed gradient of the penalty term\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.projector-Tuple{Integer, Integer, Integer}","page":"Home","title":"SimpleEvolve.projector","text":"projector(n_sites::Integer, n_levels::Integer, n_levels0::Integer)\n\nProject a Hilbert space of n_sites n_levels0-level qubits onto that of n_sites n_levels-level qubits\n\nReturns an (n_sites^n_levels, n_sites^n_levels) shaped matrix Π. To perform the projection on a vector, use ψ ← Πψ. To perform the projection on a matrix, use A ← ΠAΠ'.\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.reconstruct-Tuple{DigitizedSignal, Int64, Symbol}","page":"Home","title":"SimpleEvolve.reconstruct","text":"reconstruct(signal::DigitizedSignal,             outputsamples::Int,             method::Symbol;             secondarymethod=:polynomial,             weight=0.5,             polyorder=4,             windowradius=8,             filtercutoffratio=0.8)     Reconstruct a signal using specified interpolation methods.     Args:         signal: Input digitized signal         output_samples: Desired output length         method: Interpolation method to use     Returns:         Reconstructed signal with anti-aliasing\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.reconstruct_gradient_ti-Tuple{DigitizedSignal, Any}","page":"Home","title":"SimpleEvolve.reconstruct_gradient_ti","text":"reconstructgradientti(signal::DigitizedSignal, output_samples::Int)\n\nReconstruct a signal using trigonometric interpolation.\nArgs:\n    signal: Input digitized signal\n    output_samples: Desired output length\nReturns:\n    Reconstructed signal with anti-aliasing\n\n\n\n\n\n","category":"method"},{"location":"#SimpleEvolve.single_step","page":"Home","title":"SimpleEvolve.single_step","text":"Auxiliary function to evolve a single step in time. \n\n\n\n\n\n","category":"function"},{"location":"#SimpleEvolve.trotter_evolve-Tuple{Vector{ComplexF64}, Float64, Any, Int64, Int64, Matrix{Float64}, Any, Matrix{ComplexF64}}","page":"Home","title":"SimpleEvolve.trotter_evolve","text":"trotter_evolve     Function to evolve the state vector using trotterization of time     Time-evolves an initial quantum state ψ0 under a time-dependent Hamiltonian using a second-order Trotter-Suzuki approximation in the eigenbasis of a static part of the Hamiltonian.\n\n# Arguments\n- `ψ0::Vector{ComplexF64}`: Initial quantum state vector in the device or eigenbasis, depending on `basis`.\n- `T::Float64`: Total time of evolution.\n- `signals`: Control signals or time-dependent coefficients that define the dynamic/drive part of the Hamiltonian. Must be compatible with `_step`.\n- `n_sites::Int64`: Number of qubits or quantum sites in the system.\n- `n_levels::Int64`: Local Hilbert space dimension for each site.\n- `a_q::Matrix{Float64}`: Precomputed matrix of annihilation operators.\n- `eigvalues`: Eigenvalues of the static (time-independent) Hamiltonian.\n- `eigvectors::Matrix{ComplexF64}`: Corresponding eigenvectors of the static Hamiltonian.\n\n# Optional Keyword Arguments\n- `basis::String=\"eigenbasis\"`: Indicates the basis in which `ψ0` is defined. If `\"eigenbasis\"`, state is evolved and transformed accordingly; if not, appropriate basis rotations are applied.\n- `n_trotter_steps::Int=1000`: Number of Trotter time steps. A larger number improves accuracy but increases computational cost.\n\n# Returns\n- `ψ::Vector{ComplexF64}`: The evolved quantum state at time `T`, in the same basis as the input.\n\n\n\n\n\n","category":"method"},{"location":"#ZygoteRules._pullback-Tuple{Zygote.Context, typeof(SimpleEvolve.fftfreq), Vararg{Any}}","page":"Home","title":"ZygoteRules._pullback","text":"bandwidth_penalty_and_gradient(Ω::Vector{Float64}, ν::Float64; cutoff=0.2)\n\nComputes both the bandwidth regularization penalty and its gradient using reverse-mode AD (Zygote).\n\nArguments\n\nΩ: Real-valued flattened control signal.\nν: Sharpness of the low-pass filter's transition.\ncutoff: Normalized frequency cutoff (default: 0.2).\n\nReturns\n\npenalty: A scalar measuring deviation from the low-passed signal.\ngrad: Gradient vector of the penalty w.r.t. Ω.\n\n\n\n\n\n","category":"method"}]
}
